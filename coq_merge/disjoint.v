Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Coq.Program.Equality.
Require Export lub.

Definition disjointSpec E A B := forall C, Sub E A C -> Sub E B C -> toplike E C.

    
Lemma dis_weakening: forall E1 E2 E3 A B,
    dis (E1 ++ E3) A B ->
    wf_env (E1 ++ E2 ++ E3) ->
    WFS (E1 ++ E2 ++ E3) A -> WFS (E1 ++ E2 ++ E3) B ->
    dis (E1 ++ E2 ++ E3) A B.
Proof with auto.
  intros.
  generalize dependent E2.
  dependent induction H;intros;try solve [constructor;auto;apply toplike_weakening;auto]...
  -
    dependent destruction H2...
  -
    dependent destruction H3...
  -
    dependent destruction H3.
    dependent destruction H4...
  -
    dependent destruction H4.
    dependent destruction H5...
  -
    apply dis_RcdRcdEq...
    apply IHdis...
    dependent destruction H1...
    dependent destruction H2...
  -
    dependent destruction H4.
    dependent destruction H6.
    apply dis_RecRec with (L:=L \u L0 \u L1 \u dom (E1 ++ E2 ++ E3));intros...
    rewrite_alist (([(X, bind_sub)] ++ E1) ++ E2 ++ E3)...
    apply H2...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E2 ++ E3)...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E2 ++ E3)...
    rewrite_alist ([(X, bind_sub)] ++ E1 ++ E2 ++ E3)...
Qed.


Ltac tact_ax H1 H2 := dependent induction H1;try solve [dependent destruction H2;auto];auto.
Ltac tact_axf H1 H2:= tact_ax H1 H2;apply and_inv in H2;destruct_hypos.
Ltac tact_axsolve H1 H2 H3 H4:= tact_axf H1 H2;constructor;try eapply H3;eauto;try eapply H4;eauto.

  
Lemma disjoint_soundness:
  forall E A B, dis E A B -> disjointSpec E A B.
Proof with auto.
  intros.
  unfold disjointSpec.
  dependent induction H;intros;try solve [tact_ax H1 H2|tact_ax H2 H1|tact_axsolve H2 H3 IHSub1 IHSub2|tact_axsolve H3 H2 IHSub1 IHSub2]...
  - (* topL *)
    apply toplikeSubToplike with (A:=B)...
  - (* topR *)
    apply toplikeSubToplike with (A:=A)...    
  - (* andL *)
    dependent induction H1...
    destruct (and_inv H2).
    constructor.
    apply IHSub1 with (A3:=A1) (A4:=A2)...
    apply IHSub2 with (A3:=A1) (A4:=A2)...
  - (* andR *)
    dependent induction H2...
    destruct (and_inv H1).
    constructor.
    apply IHSub1 with (B3:=B1) (B4:=B2)...
    apply IHSub2 with (B4:=B1) (B5:=B2)...
  - (* varvar *)
    dependent induction H3... 
    +
      dependent destruction H5...
      destruct H2...
    +
      destruct (and_inv H4).
      constructor.
      apply IHSub1 with (X3:=X1)...
      apply IHSub2 with (X3:=X1)...
  - (* arrarr *)
    dependent induction H2...
    +
      dependent destruction H3...
      constructor...
      get_well_form...
    +
      destruct (and_inv H3).
      constructor...
      apply IHSub1 with (A3:=A1) (A4:=A2)...
      apply IHSub2 with (A3:=A1) (A4:=A2)...
  - (* rcdrcd *)
    dependent induction H3...
    +
      destruct (and_inv H4).
      constructor...
      apply IHSub1 with (A0:=A) (X0:=X)...
      apply IHSub2 with (A0:=A) (X0:=X)...
    +
      dependent destruction H4...
      destruct H...
  - (* rcdrcdeq *)
    dependent induction H0...
    +
      destruct (and_inv H1).
      constructor...
      apply IHSub1 with (A0:=A) (X0:=X)...
      apply IHSub2 with (A0:=A) (X0:=X)...
    +
      dependent destruction H1...
  - (* recrec *)
    dependent induction H3...
    +
      destruct (and_inv H4).
      constructor...
      eapply IHSub1...
      eapply IHSub2...
    +
      dependent destruction H7...
      clear H6.
      apply toplike_rec with (L:=L \u L0 \u L1 \u fl_tt A0 \u fl_tt A2 \u fl_tt A1 \u fv_tt A0 \u fv_tt A1 \u fv_tt A2).
      intros.
      apply H2...
      specialize_x_and_L X L0.
      add_nil.
      apply Sub_twice_to_one...
      specialize_x_and_L X L1.
      add_nil.
      apply Sub_twice_to_one...
Qed.

Lemma dis_comm: forall A B E,
    dis E A B -> dis E B A.
Proof with auto.
  intros.
  induction H...
  apply dis_RecRec with (L:=L)...
Qed.


Lemma disjoint_toplike_L:forall E A B,
    WFS E A ->
    toplike E B ->
    dis E A B.
Proof with auto.
  intros.
  apply dis_topL...
  get_well_form...
Qed.

Lemma disjoint_toplike_R:forall E A B,
    WFS E B ->
    toplike E A ->
    dis E A B.
Proof with auto.
  intros.
  apply dis_topR...
  get_well_form...
Qed.  


Lemma disjoint_completeness: forall E A B,
    wf_env E ->
    WFS E A -> WFS E B ->
    disjointSpec E A B -> dis E A B.
Proof with auto.
  unfold disjointSpec.
  intros.
  generalize dependent B.
  induction H0;intros...
  - (* bot *)
    assert (toplike E B).
    apply H2...
    apply Reflexivity...
    apply dis_topL...
  - (* nat *)
    dependent induction H1; try solve [constructor;auto]...
    +
      constructor...
      apply WFS_rec with (L:=L)...
  - (* var *)
    dependent induction H1; try solve [constructor;auto]...
    +
      destruct (X==X0)...
      subst.
      assert (toplike E (typ_fvar X0)).
      apply H2...
      inversion H3...
    +
      constructor...
      apply WFS_rec with (L:=L)...
  - (* arrow *)
    dependent induction H1; try solve [constructor;auto]...
    +
      assert (toplike E (typ_arrow A B)).
      apply H2...
      apply Reflexivity...
      apply dis_topR...
    +
      apply dis_ArrArr...
      apply IHWFS2...
      intros.
      assert (toplike E (typ_arrow typ_bot C)).
      apply H2...
      dependent destruction H3...
    +
      constructor...
      apply WFS_rec with (L:=L)...
  - (* rcd *)
    dependent induction H1; try solve [constructor;auto]...
    +
      apply disjoint_toplike_R...
      apply H2...
      apply Reflexivity...
    +
      clear IHWFS0.
      destruct (l==l0);subst...
      apply dis_RcdRcdEq...
      apply IHWFS...
      intros.
      assert (toplike E (typ_rcd l0 C)).
      apply H2...
      inversion H5...
    +
      constructor...
      apply WFS_rec with (L:=L)...
  -  (* rec *)
    dependent induction H4;try solve [constructor;auto;econstructor;eauto]...
    +
      apply disjoint_toplike_R...
      apply H5...
      apply Reflexivity...
      apply WFS_rec with (L:=L)...
      constructor...
      apply WFS_rec with (L:=L)...
    +
      clear H5 H7.
      apply dis_RecRec with (L:=L \u L0 \u dom E \u fv_tt A \u fv_tt A0 \u fl_tt A \u fl_tt A0);intros;try solve [apply H2;auto|apply H6;auto].
      apply H3...
      intros.
      rename C into T.
      assert (Sub E (typ_mu A) (Lub (typ_mu A) (typ_mu A0))).
      apply Lub_subL...
      apply WFS_rec with (L:=L0)...
      apply WFS_rec with (L:=L)...
      assert (Sub E (typ_mu A0) (Lub (typ_mu A) (typ_mu A0))).
      apply Lub_subR...
      apply WFS_rec with (L:=L0)...
      apply WFS_rec with (L:=L)...
      assert (toplike  E (Lub (typ_mu A) (typ_mu A0))).
      apply H8...
      simpl in H12.
      dependent destruction H12.
      pick fresh Y.
      specialize_x_and_L Y L1.
      apply Lub_toplike with (A:=open_tt A X) (B:=open_tt A0 X)...
      rewrite <- Lub_open...
      rewrite subst_tt_intro with (X:=Y)...
      add_nil.
      apply subst_tt_toplike2...
      constructor...
      apply Lub_fv_notin...
Qed.


Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Coq.Program.Equality.
Require Export typinginfra.

Lemma TypedReduce_ord_toplike_normal : forall (v v': exp) (A : typ),
    ord A -> toplike empty A -> typ_reduce v A v' -> v' = exp_top.
Proof with auto.
  intros.
  dependent induction H1;try solve [inversion H0]...
  - (* fold *)
    assert (False).
    apply H2...
    destruct H4...
  - (* abs *)
    assert (False).
    apply H2...
    dependent destruction H0...
    destruct H5...
  - (* merge *)
    inversion H...
  - (* rcd *)
    assert (False).
    apply H2...
    destruct H3...
Qed.

Lemma TypedReduce_toplike :
  forall A , toplike empty A ->
            forall (v1 v2 v1' v2' : exp), typ_reduce v1 A v1' -> typ_reduce v2 A v2' -> v1' = v2'.
Proof with auto.
  intros A  H.
  dependent induction H;intros...
  - (* top *)
    apply TypedReduce_ord_toplike_normal in H0...
    apply TypedReduce_ord_toplike_normal in H1...
    subst...
  - (* and *)
    dependent destruction H1;try solve [inversion H2|inversion H3]...
    dependent destruction H2;try solve [inversion H2|inversion H3]...
    f_equal...
    apply IHtoplike1 with (v1:=e) (v2:=e0)...
    apply IHtoplike2 with (v1:=e) (v2:=e0)...
  - (* arrow *)
    assert (toplike empty (typ_arrow A B)).
    constructor...
    apply TypedReduce_ord_toplike_normal in H1...
    apply TypedReduce_ord_toplike_normal in H2...
    subst...
  - (* rcd *)
    assert (toplike empty (typ_rcd l A)).
    econstructor...
    apply TypedReduce_ord_toplike_normal in H1...
    apply TypedReduce_ord_toplike_normal in H0...
    subst...
  - (* rec *)
    assert (toplike empty (typ_mu  B)).
    econstructor...
    apply TypedReduce_ord_toplike_normal in H1...
    apply TypedReduce_ord_toplike_normal in H2...
    subst...
Qed.

Lemma TypedReduce_sub: forall v v' A B,
    value v -> typ_reduce v A v' -> typing nil v Inf B -> Sub empty B A.
Proof with auto.
  intros.
  generalize dependent B.
  dependent induction H0;intros;try solve [apply AsubToplike;auto;get_well_form;auto]...
  - (* nat *)
    dependent destruction H1...
  - (* fold *)
    dependent destruction H3...
  - (* abs *)
    dependent destruction H4...
  - (* mergeL *)
    dependent destruction H.
    dependent destruction H4;apply S_andL...
    get_well_form...
    get_well_form...
  - (* mergeR *)
    dependent destruction H.
    dependent destruction H4;apply S_andR...
    get_well_form...
    get_well_form...
  - (* rcd *)
    dependent destruction H2...
    dependent destruction H...
    
Qed.


Lemma disjoint_val_consistent: forall A B v1 v2,
    disjointSpec empty A B -> value v1 -> value v2 -> typing nil v1 Inf A -> typing nil v2 Inf B -> consistencySpec v1 v2.
Proof with auto.
  intros.
  unfold consistencySpec.
  intros.
  apply TypedReduce_sub with (v':=v1') (A:=T) (B:=A) in H0...
  apply TypedReduce_sub with (v':=v2') (A:=T) (B:=B) in H1...
  unfold disjointSpec in H.
  assert (toplike empty T).
  apply H...
  apply TypedReduce_toplike with (A:=T) (v1:=v1) (v2:=v2)...
Qed.

Lemma TypedReduce_unique: forall (v v1 v2 : exp) (A: typ),
    value v -> (exists B, typing nil v Inf B) -> typ_reduce v A v1 -> typ_reduce v A v2 -> v1 = v2.
Proof with auto.
  intros.
  generalize dependent v2.
  dependent induction H1;intros...
  - (* nat *)
    dependent destruction H2...
    inversion H3...
  - (* top *)
    apply TypedReduce_toplike with (A:=A) (v1:=exp_top) (v2:=e)...
  - (* fold *)
    dependent destruction H4...
    assert (False) as q.
    apply H2...
    destruct q.
  - (* abs *)
    dependent destruction H5...
    assert (False) as q.
    apply H2...
    dependent destruction H7...
    destruct q.
  - (* and *)
    dependent destruction H2;try solve [f_equal;auto|inversion H3|inversion H2]...
  - (* mergeL *)
    dependent destruction H.
    dependent destruction H5;try solve [inversion H4]...
    +
      apply TypedReduce_ord_toplike_normal in H3...
    +
      destruct H1.
      dependent destruction H1...
      apply IHtyp_reduce...
      exists A...
      apply IHtyp_reduce...
      exists A...
    +
      destruct H1.
      dependent destruction H1...
      *
        apply disjoint_soundness in H1.
        apply disjoint_val_consistent with (v1:=e1) (v2:=e2) in H1...
        unfold consistencySpec in H1.
        apply H1 with (T:=T)...
      *
        apply H4 with (T:=T)...
  - (* mergeR *)
    dependent destruction H.
    dependent destruction H5;try solve [inversion H4]...
    +
      apply TypedReduce_ord_toplike_normal in H3...
    +
      symmetry.
      destruct H1.
      dependent destruction H1...
      *
        apply disjoint_soundness in H1.
        apply disjoint_val_consistent with (v1:=e1) (v2:=e2) in H1...
        unfold consistencySpec in H1.        
        apply H1 with (T:=T)...
      *
        apply H4 with (T:=T)...
    +
      destruct H1.
      dependent destruction H1...
      apply IHtyp_reduce...
      exists B...
      apply IHtyp_reduce...
      exists B...
  - (* rcd *)
    dependent destruction H...
    dependent destruction H3...
    +
      assert (False) as q.
      apply H2...
      destruct q.
    +
      f_equal...
      apply IHtyp_reduce...
      destruct_hypos.
      dependent destruction H0...
      exists A...
Qed.


Lemma TypedReduce_trans : forall v v1 v2 A B,
    value v -> typ_reduce v A v1 -> typ_reduce v1 B v2 -> typ_reduce v B v2.
Proof with auto.
  intros.
  generalize dependent B.
  generalize dependent v2.
  dependent induction H0;intros...
  - (* top *)
    dependent induction H3...
  - (* fold *)
    assert (expr (exp_fold (typ_mu A) e)).
    constructor...
    get_type...
    dependent induction H3...
    +
      constructor...
      apply Transitivity with (B:=typ_mu B)...
    +
      constructor.
      apply IHtyp_reduce1 with (B0:=B)...
      apply IHtyp_reduce2 with (B1:=B)...
  - (* abs *)
    dependent induction H4...
    +
      constructor...
      apply Transitivity with (B:=B2)...
    +
      constructor.
      apply IHtyp_reduce1 with (B3:=B2)...
      apply IHtyp_reduce2 with (B3:=B2)...
  - (* and *)
    assert (expr e).
    get_well_form... 
    dependent induction H1...
    +
      constructor...
      apply IHtyp_reduce0 with (e4:=e1) (e5:=e2)...
      apply IHtyp_reduce3 with (e3:=e1) (e5:=e2)...
  - (* mergeL *)
    dependent destruction H.
    dependent induction H4;try solve [apply tred_mergeL;auto;constructor;auto;get_well_form;auto]...
  - (* mergeR *)
    dependent destruction H.
    dependent induction H4;try solve [apply tred_mergeR;auto;constructor;auto;get_well_form;auto]...
  - (* rcd *)
    dependent destruction H.
    dependent induction H2...
    +
      constructor...
      get_well_form...
    +
      constructor.
      apply IHtyp_reduce1 with (e3:=e2)...
      apply IHtyp_reduce2 with (e4:=e2)...
Qed.

Lemma consistent_afterTR : forall v A B C v1 v2,
    value v ->
    typing nil v Inf C ->
    typ_reduce v A v1 ->
    typ_reduce v B v2 ->
    consistencySpec v1 v2.
Proof with auto.
  intros.
  unfold consistencySpec.
  intros.
  apply TypedReduce_trans with (A:=A) (v:=v) in H3...
  apply TypedReduce_trans with (A:=B) (v:=v) in H4...
  apply TypedReduce_unique with (v:=v) (A:=T)...
  exists C...
Qed.

Lemma TypedReduce_prv_value: forall v A v',
    value v -> typ_reduce v A v' -> value v'.
Proof with auto.
  intros.
  dependent induction H0;try solve [dependent destruction H;auto]...
  - (* fold *)
    dependent destruction H.
    constructor...
    get_type...
  - (* abs *)
    constructor...
    dependent destruction H0.
    apply lc_abs with (L:=L)...
    get_type...
Qed.

Lemma reduce_toplike_typing: forall e1 T,
    value e1 ->
    (exists S, typing nil e1 Inf S) ->
    toplike empty T ->
    typing nil e1 Chk T.
Proof with auto.
  intros.
  destruct H0.
  apply typing_sub with (A:=x)...
  apply AsubToplike...
  get_well_form...
Qed.  

Lemma reduce_to_typing: forall e1 e2 T,
    value e1 ->
    (exists S, typing nil e1 Inf S) ->
    typ_reduce e1 T e2 ->
    typing nil e1 Chk T.
Proof with auto.
  intros.
  dependent induction H1...
  - (* nat *)
    apply typing_sub with (A:=typ_nat)...
  - (* top *)
    apply reduce_toplike_typing...
  - (* fold *)
    destruct H0.
    dependent destruction H0.
    apply typing_sub with (A:=typ_mu A)...
  - (* abs *)
    destruct H0.
    dependent destruction H0.
    apply typing_sub with (A:=typ_arrow A1 A2)...
    apply typing_abs with (L:=L)...
  - (* and *)
    specialize (IHtyp_reduce1 H H0).
    specialize (IHtyp_reduce2 H H0).
    destruct H0.
    apply typing_inf_chk_sub with (A:=x) in IHtyp_reduce1...
    apply typing_inf_chk_sub with (A:=x) in IHtyp_reduce2...
    apply typing_sub with (A:=x)...
  - (* mergeL *)
    dependent destruction H.
    destruct H1.
    dependent destruction H1.
    +
      assert (typing empty e1 Chk T).
      apply IHtyp_reduce...
      exists A...
      assert (Sub empty A T).
      apply typing_inf_chk_sub with (e:=e1)...
      apply typing_sub with (A:=typ_and A B).
      apply typing_merge...
      apply S_andL...
      get_well_form...
    +
      assert (typing empty e1 Chk T).
      apply IHtyp_reduce...
      exists A...
      assert (Sub empty A T).
      apply typing_inf_chk_sub with (e:=e1)...
      apply typing_sub with (A:=typ_and A B).
      apply typing_mergev...
      apply S_andL...
      get_well_form...
  - (* mergeR *)
    dependent destruction H.
    destruct H1.
    dependent destruction H1.
    +
      assert (typing empty e2 Chk T).
      apply IHtyp_reduce...
      exists B...
      assert (Sub empty B T).
      apply typing_inf_chk_sub with (e:=e2)...
      apply typing_sub with (A:=typ_and A B).
      apply typing_merge...
      apply S_andR...
      get_well_form...
    +
      assert (typing empty e2 Chk T).
      apply IHtyp_reduce...
      exists B...
      assert (Sub empty B T).
      apply typing_inf_chk_sub with (e:=e2)...
      apply typing_sub with (A:=typ_and A B).
      apply typing_mergev...
      apply S_andR...
      get_well_form...
  - (* rcd *)
    dependent destruction H.
    destruct_hypos.
    dependent destruction H0...
    apply typing_sub with (A:=typ_rcd l A)...
    constructor...
    apply IHtyp_reduce in H...
    apply typing_inf_chk_sub with (e:=e1)...
    exists A...
Qed.

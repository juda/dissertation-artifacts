Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Coq.Program.Equality.
Require Export unfolding.


Fixpoint Lub (A:typ)  :=
  fix Lub_aux (B:typ) : typ :=
    match A with
    | typ_bot => match B with
                 | typ_and B1 B2 => typ_and (Lub_aux B1) (Lub_aux B2)
                 | typ_arrow _ B2 => typ_arrow typ_bot (Lub_aux B2)
                 | typ_mu B1 => typ_mu (Lub_aux B1)
                 | typ_rcd l B1 => typ_rcd l (Lub_aux B1)
                 | _ => B
                 end
    | typ_nat => match B with
                 | typ_nat => A
                 | typ_and B1 B2 => typ_and (Lub_aux B1) (Lub_aux B2)
                 | typ_bot => typ_nat                           
                 | _ => typ_top
                 end
    | typ_top => match B with
                 | typ_and B1 B2 => typ_and (Lub_aux B1) (Lub_aux B2)
                 | _ => typ_top
                 end
    | typ_arrow A1 A2 => match B with
                         | typ_bot => typ_arrow typ_bot (Lub A2 typ_bot)
                         | typ_arrow B1 B2 => typ_arrow typ_bot (Lub A2 B2)
                         | typ_and B1 B2 => typ_and (Lub_aux B1) (Lub_aux B2)
                         | _ => typ_top
                         end
    | typ_and A1 A2 => match B with
                       | typ_bot => typ_and (Lub A1 typ_bot) (Lub A2 typ_bot)
                       | _ => typ_and (Lub A1 B) (Lub A2 B)
                       end
      
    | typ_rcd l1 A1 => match B with
                       | typ_bot => typ_rcd l1 (Lub A1 typ_bot)
                       | typ_rcd l2 A2 => if l1 == l2 then typ_rcd l1 (Lub A1 A2) else typ_top
                       | typ_and A2 A3 => typ_and (Lub_aux A2) (Lub_aux A3)
                       | _ => typ_top
                       end
    | typ_bvar x => match B with
                       | typ_bot => A
                       | typ_bvar y => if x == y then A else typ_top
                       | typ_and A2 A3 => typ_and (Lub_aux A2) (Lub_aux A3)
                       | _ => typ_top
                       end
    | typ_fvar x => match B with
                       | typ_bot => A
                       | typ_fvar y => if x == y then A else typ_top
                       | typ_and A2 A3 => typ_and (Lub_aux A2) (Lub_aux A3)
                       | _ => typ_top
                       end
    | typ_mu A1 => match B with
                       | typ_bot => typ_mu (Lub A1 typ_bot)
                       | typ_mu B1 => typ_mu (Lub A1 B1)
                       | typ_and A2 A3 => typ_and (Lub_aux A2) (Lub_aux A3)
                       | _ => typ_top
                       end
    end.



Lemma Lub_arrowL: forall A B C D,
    (Lub (typ_arrow A B) (typ_and C D)) = typ_and (Lub (typ_arrow A B) C) (Lub (typ_arrow A B) D).
Proof with auto.
  intros.
  simpl...
Qed.

Lemma Lub_rcdL: forall  l B C T,
    (Lub (typ_rcd l T) (typ_and B C)) = typ_and (Lub (typ_rcd l T) B) (Lub (typ_rcd l T) C).
Proof with auto.
  intros.
  simpl...
Qed.

Lemma Lub_varL: forall  x B C ,
    (Lub (typ_fvar x) (typ_and B C)) = typ_and (Lub (typ_fvar x) B) (Lub (typ_fvar x) C).
Proof with auto.
  intros.
  simpl...
Qed.
Lemma Lub_recL: forall   B C T,
    (Lub (typ_mu  T) (typ_and B C)) = typ_and (Lub (typ_mu  T) B) (Lub (typ_mu  T) C).
Proof with auto.
  intros.
  simpl...
Qed.

Lemma Lub_topL: forall   B C ,
    (Lub typ_top (typ_and B C)) = typ_and (Lub typ_top B) (Lub typ_top C).
Proof with auto.
  intros.
  simpl...
Qed.

Lemma Lub_natL: forall   B C ,
    (Lub typ_nat (typ_and B C)) = typ_and (Lub typ_nat B) (Lub typ_nat C).
Proof with auto.
  intros.
  simpl...
Qed.

Lemma Lub_botL: forall   B C ,
    (Lub typ_bot (typ_and B C)) = typ_and (Lub typ_bot B) (Lub typ_bot C).
Proof with auto.
  intros.
  simpl...
Qed.  
  


Lemma Lub_andR : forall A1 A2 B,
    Lub (typ_and A1 A2) B = typ_and (Lub A1 B) (Lub A2 B).
Proof with auto.
  intros.
  induction B...
Qed.


Lemma Lub_fv_notin_and: forall A B1 B2 X,
    X \notin fv_tt (Lub A (typ_and B1 B2)) ->
    X \notin fv_tt (Lub A B1) \u fv_tt (Lub A B2).
Proof with auto.
  intros A.
  induction A;intros...
  -
    simpl in H.
    apply notin_union in H.
    destruct_hypos.
    apply IHA1 in H.
    apply IHA2 in H0...
    apply notin_union in H.
    apply notin_union in H0.
    destruct_hypos...
    apply notin_union.
    split;rewrite Lub_andR...
Qed.

    
Lemma Lub_fv_notin: forall A B X,
    X \notin fv_tt A \u fv_tt B ->
    X \notin fv_tt (Lub A B).
Proof with auto.
  intros A.
  induction A;intros;try solve [induction B;simpl in *;auto]...
  -
    induction B...
    simpl in *.
    destruct (n==n0)...
    apply notin_union in H.
    destruct_hypos.
    apply notin_union in H0.
    destruct_hypos...
  -
    induction B...
    simpl in *.
    destruct (a==a0)...    
    apply notin_union in H.
    destruct_hypos.
    apply notin_union in H0.
    destruct_hypos...
  -
    induction B;try solve [simpl in *;auto]...
    simpl...
    destruct (a==a0)...
    simpl in *...
Qed.

Lemma Lub_open: forall A  B (X:atom),
    X \notin fv_tt A \u fv_tt B ->
    (open_tt (Lub A B) X) = Lub (open_tt A X) (open_tt B X).
Proof with auto.
  unfold open_tt.
  intros A.
  generalize 0.
  dependent induction A;intros...
  -
    induction B;simpl in *;try solve [f_equal;auto].
    destruct (n==n0)...
  -
    generalize n.
    dependent induction B;intros;try solve [simpl in *;f_equal;auto].
    simpl...
    destruct (n1==n0)...
  -
    induction B;simpl in *;try solve [f_equal;auto].
    destruct (n==n0)...
  -
    induction B;try solve [simpl in *;destruct (n0==n);auto].
    +
      simpl...
      destruct (n==n1);destruct (n0==n);destruct (n0==n1);subst;simpl;try solve [destruct n;auto|destruct n2;auto]...
      destruct (n1==n1)...
      destruct (X==X)...
      destruct n...
      destruct n...
      destruct (n0==n1)...
      destruct n2...
      destruct (n1==n1)...
      destruct n4...
      destruct (n==n1)...
      destruct n2...
    +
      simpl...
      destruct (n0==n)...
      apply notin_union in H.
      destruct_hypos.
      simpl in *.
      apply notin_singleton_1 in H0.
      destruct (X==a)...
      destruct H0...
    +
      simpl in H.
      assert (X `notin` union (fv_tt n) (fv_tt B1)) by auto.
      apply IHB1 in H0.
      assert (X `notin` union (fv_tt n) (fv_tt B2)) by auto.
      apply IHB2 in H1.
      simpl...
      destruct (n0==n)...
      *
        subst.
        simpl in *...
        destruct (n==n)...
        f_equal...
        destruct n0...
      *
        simpl in *...
        destruct (n0==n)...
        destruct n1...
        f_equal...
  -
    induction B;try solve [simpl in *;f_equal;auto].
    simpl.
    destruct (n==n0)...
    destruct (a==X)...
    apply notin_union in H.
    destruct_hypos.
    simpl in *.
    apply notin_singleton_1 in H.
    destruct H...
    simpl.
    destruct (a==a0)...
  -
    simpl in H.
    apply notin_union in H.
    destruct_hypos.
    apply notin_union in H.
    destruct_hypos.
    assert (X `notin` union (fv_tt A1) (fv_tt B)) by auto.
    apply IHA1 with (n:=n) in H2...
    assert (X `notin` union (fv_tt A2) (fv_tt B)) by auto.
    apply IHA2 with (n:=n) in H3...
    induction B;simpl;try solve [f_equal;auto].
    destruct (n==n0);subst;simpl in *.
    destruct (n0==n0);simpl in *...
    f_equal...
    destruct n...
    destruct (n==n0);simpl in *...
    destruct n1...
    f_equal...
  -    
    dependent induction B;try solve [simpl in *;f_equal;auto].
    +
      simpl...
      f_equal...
      specialize (IHA (S n) typ_bot X).
      rewrite IHA...
    +
      simpl...
      destruct (n==n0)...
  -
    induction B;try solve [simpl in *;f_equal;auto].
    +
      simpl in *...
      f_equal...
      specialize (IHA2 n typ_bot X).
      rewrite IHA2...
    +
      simpl...
      destruct (n==n0)...
  -
    induction B;try solve [simpl in *;f_equal;auto].
    +
      simpl in *...
      f_equal...
      specialize (IHA n typ_bot X).
      rewrite IHA...
    +
      simpl...
      destruct (n==n0)...
    +
      simpl...
      destruct (a==a0)...
      simpl...
      f_equal...
Qed.

Lemma Lub_botRec: forall A,
    Lub typ_bot (typ_mu A) = typ_mu (Lub typ_bot A).
Proof with auto.
  intros...
Qed.  

Lemma WFS_Lub: forall E A B,
    WFS E A ->
    WFS E B ->
    WFS E (Lub A B).
Proof with auto.
  intros.
  generalize dependent B.
  induction H;intros;try solve [induction H0;simpl;auto]...
  -
    induction H0;try solve [simpl;auto]...
    +
      rewrite Lub_botRec...
      apply WFS_rec with (L:=L \u fv_tt A);intros.
      rewrite subst_tt_intro with (X:=X)...
      apply subst_tt_wfs...
      constructor...
      rewrite Lub_open...
      rewrite Lub_open...
      apply Lub_fv_notin...
      rewrite Lub_open...
  -
    induction H0;simpl...
    destruct (X==X0)...    
  -
    induction H1;simpl...
  -
    induction H1;simpl...
    constructor...
    apply IHWFS1...
    apply WFS_rec with (L:=L)...
    apply IHWFS2...
    apply WFS_rec with (L:=L)...
  -
    induction H0;simpl...
    destruct (l==l0)...
  -
    induction H3;simpl...
    +
      apply WFS_rec with (L:=L \u fv_tt A);intros.
      rewrite subst_tt_intro with (X:=X)...
      apply subst_tt_wfs...
      constructor...
      rewrite Lub_open...
      rewrite Lub_open...
      apply Lub_fv_notin...
      rewrite Lub_open...
    +
      clear H4 H6.
      apply WFS_rec with (L:=L \u L0 \u fv_tt A \u fv_tt A0);intros...
      assert (WFS ([(X, bind_sub)] ++ E) (open_tt (Lub A A0) X)).
      rewrite Lub_open...
      rewrite subst_tt_intro with (X:=X)...
      apply subst_tt_wfs...
      apply Lub_fv_notin...
      rewrite Lub_open...
Qed.

Lemma type_Lub: forall  A B,
    type A ->
    type B ->
    type (Lub A B).
Proof with auto.
  intros.
  generalize dependent B.
  induction H;intros;try solve [induction H0;simpl;auto]...
  -
    induction H0;try solve [simpl;auto]...
    +
      rewrite Lub_botRec...
      apply type_mu with (L:=L \u fv_tt T);intros.
      rewrite Lub_open...
  -
    induction H0;simpl...
    destruct (X==X0)...    
  -
    induction H1;simpl...
  -
    induction H1;simpl...
    constructor...
    apply IHtype1...
    apply type_mu with (L:=L)...
    apply IHtype2...
    apply type_mu with (L:=L)...
  -
    induction H0;simpl...
    destruct (l==l0)...
  -
    induction H1;simpl...
    +
      apply type_mu with (L:=L \u fv_tt T);intros.
      rewrite Lub_open...
    +
      apply type_mu with (L:=L \u L0 \u fv_tt T \u fv_tt T0);intros...
      rewrite Lub_open...
Qed.

Lemma and_dist : forall E A1 A2 B1 B2,
    WFS E A1 -> WFS E B1 -> WFS E A2 -> WFS E B2 -> wf_env E ->
    equiv E (typ_and (typ_and A1 A2) (typ_and B1 B2)) (typ_and (typ_and A1 B1) (typ_and A2 B2)).
Proof with auto.
  intros.
  unfold equiv.
  split.
  -
    apply S_and.
    apply S_and.
    apply S_andL...
    apply S_andL...
    apply Reflexivity...
    apply S_andR...
    apply S_andL...
    apply Reflexivity...
    apply S_and.
    apply S_andL...
    apply S_andR...
    apply Reflexivity...
    apply S_andR...
    apply S_andR...
    apply Reflexivity...
  -
    apply S_and.
    apply S_and.
    apply S_andL...
    apply S_andL...
    apply Reflexivity...
    apply S_andR...
    apply S_andL...
    apply Reflexivity...
    apply S_and.
    apply S_andL...
    apply S_andR...
    apply Reflexivity...
    apply S_andR...
    apply S_andR...
    apply Reflexivity...
Qed.

    
Lemma Lub_andL: forall E A B C,
    WFS E A -> WFS E B -> WFS E C -> wf_env E ->
    equiv E (Lub A (typ_and B C)) (typ_and (Lub A B) (Lub A C)).
Proof with auto.
  intros.
  unfold equiv.
  induction H...
  -
    split;simpl;apply Reflexivity...
    constructor...
    induction H0...
    induction H1...
    constructor...
    induction H0...
    induction H1...
  -
    split.
    +
      rewrite Lub_botL.
      apply Reflexivity...
      constructor;apply WFS_Lub...
    +
      rewrite Lub_botL.
      apply Reflexivity...
      constructor;apply WFS_Lub...
  -
    split;simpl;apply Reflexivity...
    constructor...
    induction H0...
    induction H1...
    constructor...
    induction H0...
    induction H1...
  -
    split;simpl;apply Reflexivity...
    constructor...
    induction H0...
    destruct (X==X0)...
    induction H1...
    destruct (X==X0)...
    constructor...
    induction H0...
    destruct (X==X0)...
    induction H1...
    destruct (X==X0)...
  -
    split.
    +
      destruct IHWFS1...
      destruct IHWFS2...
      rewrite Lub_arrowL.
      apply Reflexivity...
      constructor...
      apply WFS_Lub...
      apply WFS_Lub...
    +
      destruct IHWFS1...
      destruct IHWFS2...
      rewrite Lub_arrowL...
      apply Reflexivity...
      constructor...
      apply WFS_Lub...
      apply WFS_Lub...
  -
    destruct IHWFS1...
    destruct IHWFS2...
    apply and_inv in H4.
    apply and_inv in H6.
    destruct_hypos.
    split.
    +      
      constructor.
      rewrite Lub_andR.
      rewrite Lub_andR.
      apply S_and.
      apply S_andL...
      apply WFS_Lub...
      apply S_andR...
      apply WFS_Lub...
      rewrite Lub_andR.
      rewrite Lub_andR.
      apply S_and.
      apply S_andL...
      apply WFS_Lub...
      apply S_andR...
      apply WFS_Lub...
    +
      rewrite Lub_andR.
      rewrite Lub_andR.
      rewrite Lub_andR.
      apply Transitivity with (B:=typ_and (typ_and (Lub A B) (Lub A C)) (typ_and (Lub B0 B) (Lub B0 C)))...
      {
        apply and_dist; try solve [apply WFS_Lub;auto]...
      }
       constructor...
      apply S_andL...
      constructor;apply WFS_Lub...
      apply S_andR...
      constructor;apply WFS_Lub...
  -
    split; try solve [simpl;apply Reflexivity;auto]...
    +
      rewrite Lub_rcdL...
      apply Reflexivity...
      constructor;apply WFS_Lub...
    +
      rewrite Lub_rcdL...
      apply Reflexivity...
      constructor;apply WFS_Lub...
  -
    split; try solve [simpl;apply Reflexivity;auto]...
    +
      rewrite Lub_recL...
      apply Reflexivity...
      constructor;apply WFS_Lub...
      apply WFS_rec with (L:=L)...
      apply WFS_rec with (L:=L)...
    +
      rewrite Lub_recL...
      apply Reflexivity...
      constructor;apply WFS_Lub...
      apply WFS_rec with (L:=L)...
      apply WFS_rec with (L:=L)...
Qed.


Lemma open_and: forall A B1 B2 n,
    (open_tt_rec n A (typ_and B1 B2)) = typ_and (open_tt_rec n A B1) (open_tt_rec n A B2).
Proof with auto.
  intros.
  simpl...
Qed.

Lemma Lub_toplike_add: forall E A B,
    toplike E A ->
    toplike E B ->
    toplike E (Lub A B).
Proof with auto.
  intros.
  generalize dependent B.
  induction H;intros...
  -
    induction H0;simpl...
  -
    induction H1;simpl...
    constructor...
    apply IHtoplike1...
    apply toplike_rec with (L:=L)...
    apply IHtoplike2...
    apply toplike_rec with (L:=L)...
  -
    induction H1;simpl...
    get_well_form...
    get_well_form...
  -
    induction H0;simpl...
    get_well_form...
    destruct (l==l0)...
    get_well_form...
    get_well_form...
  -
    induction H1;simpl...
    get_well_form...
    get_well_form...
    apply toplike_rec with (L:=L \u L0 \u fv_tt B \u fv_tt B0)...
    intros.
    rewrite Lub_open...
Qed.

Lemma subst_arrow: forall X C A B,
    subst_tt X C (typ_arrow A B) = typ_arrow (subst_tt X C A) (subst_tt X C B).
Proof with auto.
  intros...
Qed.

Lemma subst_and: forall X C A B,
    subst_tt X C (typ_and A B) = typ_and (subst_tt X C A) (subst_tt X C B).
Proof with auto.
  intros...
Qed.

Lemma subst_top: forall X C ,
    subst_tt X C typ_top = typ_top.
Proof with auto.
  intros...
Qed.

Lemma subst_nat: forall X C ,
    subst_tt X C typ_nat = typ_nat.
Proof with auto.
  intros...
Qed.

Lemma subst_bot: forall X C ,
    subst_tt X C typ_bot = typ_bot.
Proof with auto.
  intros...
Qed.

Lemma subst_rec: forall X A C,
    subst_tt X C (typ_mu A) = typ_mu (subst_tt X C A).
Proof with auto.
  intros...
Qed.

Lemma Lub_topA: forall E A,
    wf_env E->
    toplike E (Lub typ_top A).
Proof with auto.
  intros.
  induction A;simpl...
Qed.  

Lemma Lub_bot_substL: forall B A  X,
    Lub typ_bot (subst_tt X A B) = subst_tt X (Lub typ_bot A) (Lub typ_bot B).
Proof with auto.
  intros B.
  induction B;intros;try solve [simpl;f_equal;auto]...
  simpl...
  destruct (a==X)...
Qed.

Lemma Lub_bot_substR: forall B A  X,
    Lub  (subst_tt X A B) typ_bot = subst_tt X (Lub A typ_bot ) (Lub  B typ_bot ).
Proof with auto.
  intros B.
  induction B;intros;try solve [simpl;f_equal;auto]...
  simpl...
  destruct (a==X)...
Qed.

    
Lemma Lub_toplike_subst: forall E A,
    WFS E A -> forall B, WFS E B ->
    toplike E (Lub A B) ->
    forall C D X,
      WFS E C -> WFS E D -> wf_env E ->  X \notin fl_tt A \u fl_tt B ->
    toplike E (Lub (subst_tt X (typ_rcd X C) A) (subst_tt X (typ_rcd X D) B)).
Proof with auto.
  intros E A HA.
  induction HA;intros...
  - (* top *)
    rewrite subst_top.
    apply Lub_topA...
  - (* bot *)
    rewrite subst_bot.
    rewrite Lub_bot_substL...
    apply subst_tt_toplike...
    apply WFS_Lub...          
  - (* nat *)
    induction H;try solve [simpl in *;inversion H0]...
    +
      rewrite subst_nat.
      simpl...
      destruct (X0==X)...
    +
      rewrite subst_and.
      rewrite subst_nat.
      rewrite Lub_natL...
      rewrite Lub_natL in H0.
      dependent destruction H0.
      assert (subst_tt X (typ_rcd X C) typ_nat = typ_nat) by auto.
      rewrite <- H0.
      simpl in H4...
  - (* var *)
    induction H0;try solve [simpl in *;destruct (X==X0);auto]...
    +
      simpl in H1...
      inversion H1.
    +
      simpl in *...
      destruct (X==X1)...
      inversion H1.
      destruct (X==X0);destruct (X1==X0)...
      subst.
      destruct n...
      simpl...
      destruct (X==X1)...
      subst.
      destruct n...
    +
      rewrite subst_and.
      rewrite Lub_varL in H1.
      simpl.
      destruct (X==X0)...
      *
        rewrite Lub_rcdL.
        subst.
        assert ((typ_rcd X0 C) = (subst_tt X0 (typ_rcd X0 C) X0)).
        simpl.
        destruct (X0==X0)...
        destruct n...
        rewrite H0...
        simpl in H5...
        dependent destruction H1...
      *
        rewrite Lub_varL.
        assert ((typ_fvar X) = (subst_tt X0 (typ_rcd X0 C) X)).
        simpl.
        destruct (X==X0)...
        destruct n...
        rewrite H0...
        simpl in H5...
        dependent destruction H1...
    +
      simpl...
      destruct (X==X0)...
      subst...
      simpl in H5...
      simpl...
      destruct (X0==l)...
      apply notin_union in H5.
      destruct H5.
      apply notin_union in H6.
      destruct H6.
      apply notin_singleton_1 in H6...
      destruct H6...
  - (* arrow *)
    induction H;try solve [simpl in *;destruct (X==X0);auto]...
    +
      rewrite subst_bot.
      simpl in H0.
      dependent destruction H0.
      simpl.
      constructor...
      rewrite Lub_bot_substR...
      apply subst_tt_toplike...
      apply WFS_Lub...      
    +
      rewrite subst_arrow.
      simpl...
      destruct (X0==X)...
    +
      clear IHWFS1 IHWFS2.
      simpl in *.
      dependent destruction H0.
      constructor...
    +
      rewrite Lub_arrowL in H0.
      rewrite subst_arrow.
      rewrite subst_and.
      rewrite Lub_arrowL.
      dependent destruction H0.
      simpl in *...
  - (* and *)
    rewrite Lub_andR in H0.
    rewrite subst_and.
    rewrite Lub_andR.
    dependent destruction H0.
    simpl in H4...
  - (* rcd *)
    induction H;try solve [simpl in *;destruct (X==X0);auto]...
    +
      simpl in *...
      dependent destruction H0.
      constructor...
      apply IHHA with (X:=X) (C:=C) (D:=D) in H0...
    +
      simpl...
      destruct (X0==X)...
      simpl in H4...
      destruct (l==X)...
      subst.
      apply notin_union in H4.
      destruct H4.
      apply notin_union in H4.
      destruct H4.
      apply notin_singleton_1 in H4.
      destruct H4...
    +
      rewrite subst_and.
      simpl in H4.
      rewrite Lub_rcdL in H0.
      dependent destruction H0.
      simpl...
    +
      simpl in H0.
      destruct (l==l0);subst...
      *
        dependent destruction H0.
        simpl in *...
        destruct (l0==l0)...
      *
        simpl...
        destruct (l==l0)...
        assert (False).
        apply n...
        destruct H5.
  - (* rec *)
    induction H3;try solve [simpl in *;destruct (X==X0);auto]...
    +
      simpl in H4.
      rewrite subst_bot.
      simpl.
      dependent destruction H4.
      apply toplike_rec with (L:=L \u L0 \u fv_tt A \u {{X}} \u fv_tt C).
      intros.
      rewrite Lub_bot_substR...
      rewrite subst_tt_open_tt_var...
      apply subst_tt_toplike...
      apply WFS_Lub...
      add_nil.
      apply WFS_weakening...
      apply type_Lub...
      constructor.
      get_type...
    +
      simpl...
      destruct (X0==X)...
    +
      rewrite subst_and.
      rewrite Lub_recL in H4.
      dependent destruction H4.
      simpl in H8...
      simpl...      
    +
      clear H9 H11.
      simpl in H4.
      dependent destruction H4.
      simpl...
      apply toplike_rec with (L:=L \u L0 \u L1 \u  {{X}} \u fv_tt A \u fv_tt A0 \u dom E \u fv_tt C \u fv_tt D).
      intros.
      rewrite Lub_open.
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      apply H2...
      specialize_x_and_L X0 L1.
      rewrite Lub_open in H4...
      add_nil.
      apply WFS_weakening...
      add_nil.
      apply WFS_weakening...
      apply notin_union.
      split;apply notin_fl_tt_open...
      constructor.
      get_type...
      constructor.
      get_type...
      apply notin_union.
      split;apply notin_fv_subst2...
Qed.

Lemma Lub_botArr: forall A B,
    Lub typ_bot (typ_arrow A B) = typ_arrow typ_bot (Lub typ_bot B).
Proof with auto.
  intros...
Qed.  


Lemma Lub_botRcd: forall A B,
    Lub typ_bot (typ_rcd A B) = typ_rcd A (Lub typ_bot B).
Proof with auto.
  intros...
Qed.

Lemma open_and_dist: forall A B X,
    open_tt (typ_and A B) X = typ_and (open_tt A X) (open_tt B X).
Proof with auto.
  intros...
Qed.  

Lemma Lub_bot_open: forall A (X :atom),
    Lub typ_bot (open_tt A X) = open_tt (Lub typ_bot A) X.
Proof with auto.
  intros...
  unfold open_tt.
  generalize 0.
  induction A;intros...
  +
    simpl...
    destruct (n0==n)...
  +
    rewrite Lub_botL.
    simpl.
    f_equal...
  +
    rewrite Lub_botRec.
    simpl.
    f_equal...
  +
    rewrite Lub_botArr.
    simpl...
    f_equal...
  +
    rewrite Lub_botRcd.
    simpl.
    f_equal...
Qed.

Lemma Lub_open_bot: forall A (X :atom),
    Lub (open_tt A X) typ_bot = open_tt (Lub A typ_bot) X.
Proof with auto.
  intros...
  unfold open_tt.
  generalize 0.
  induction A;intros;simpl;try solve [f_equal;auto]...
  destruct (n0==n)...
Qed.

Lemma Lub_bot_toplikeL: forall E A,
    WFS E A ->
    toplike E (Lub typ_bot A) ->
    toplike E A.
Proof with auto.
  intros.
  induction H...
  +
    rewrite Lub_botArr in H0.
    dependent destruction H0...
  +
    rewrite Lub_botL in H0.
    dependent destruction H0...
  +
    rewrite Lub_botRcd in H0.
    dependent destruction H0...
  +
    rewrite Lub_botRec in H0.
    dependent destruction H0.
    apply toplike_rec with (L:=L \u L0 \u fv_tt A).
    intros.
    apply H3...
    rewrite Lub_bot_open...
Qed.

Lemma Lub_bot_toplikeR: forall E A,
    WFS E A ->
    toplike E (Lub  A typ_bot) ->
    toplike E A.
Proof with auto.
  intros.
  induction H;try solve [simpl in *;dependent destruction H0;auto]...
  +
    simpl in H0.
    dependent destruction H0.
    apply toplike_rec with (L:=L \u L0 \u fv_tt A).
    intros.
    apply H3...
    rewrite Lub_open_bot...
Qed.

Lemma toplike_twice_to_one : forall A X E,
    X \notin fv_tt A ->
    WFS ([(X, bind_sub)] ++ E) (open_tt A X) ->
    toplike ([(X, bind_sub)] ++ E) (open_tt A (typ_rcd X (open_tt A X))) ->
    toplike ([(X, bind_sub)] ++ E) (open_tt A X).
Proof with auto.
  intros.
  rewrite subst_tt_intro with (X:=X) in H1...
  apply toplike_subst_rev in H1...
  destruct H1...
  dependent destruction H1...
  get_type...
Qed.  
  
  
Lemma Lub_toplike: forall E A B C,
    Sub E A C ->
    Sub E B C ->
    toplike E (Lub A B) ->
    toplike E C.
Proof with auto.
  intros.
  generalize dependent B.
  dependent induction H;intros...
  - (* nat *)
    dependent induction H0...
    +
      rewrite Lub_natL in H2.
      dependent destruction H2...
    +
      rewrite Lub_natL in H2.
      dependent destruction H2...
  - (* var *)
    dependent induction H1...
    +
      simpl in H3.
      destruct (X==X)...
      destruct n...
    +
      rewrite Lub_varL in H3.
      dependent destruction H3...
    +
      rewrite Lub_varL in H3.
      dependent destruction H3...
  - (* bot *)
    apply Lub_bot_toplikeL in H2...
    apply toplikeSubToplike with (A:=B)...
    get_well_form...
  - (* arrow *)
    dependent induction H1...
    +
      simpl in H3.
      dependent destruction H3.
      constructor...
      apply IHSub2 with (B:=A2)...
      apply Lub_toplike_add...
      apply Lub_bot_toplikeR in H3...
      get_well_form...
      apply Lub_bot_toplikeR in H3...
      get_well_form...
      get_well_form...
    +
      simpl in H2.
      dependent destruction H2...
      constructor...
      apply IHSub2 with (B:=A3)...
      get_well_form...
    +
      rewrite Lub_arrowL in H3.
      dependent destruction H3...
    +
      rewrite Lub_arrowL in H3.
      dependent destruction H3...
  - (* and *)
    apply and_inv in H1...
    destruct_hypos...
    constructor...
    apply IHSub1 with (B:=B)...
    apply IHSub2 with (B:=B)...
  - (* andL *)
    rewrite Lub_andR in H2.
    dependent destruction H2...
    apply IHSub with (B0:=B0)...
  - (* andR *)
    rewrite Lub_andR in H2.
    dependent destruction H2...
    apply IHSub with (B0:=B0)...
  - (* rec *)
    dependent induction H3...
    +
      simpl in H5.
      dependent destruction H5.
      apply toplike_rec with (L:=L \u L0 \u fv_tt A1 \u fv_tt A2 )...
      intros...
      specialize_x_and_L X L.
      apply H2 in H1...
      *
        apply toplike_twice_to_one in H1...
      *
        specialize_x_and_L X L0.
        rewrite <- Lub_open_bot in H5...
        apply Lub_bot_toplikeR in H5...
        apply Lub_toplike_add...
        rewrite subst_tt_intro with (X:=X)...
        apply subst_tt_toplike...
        rewrite subst_tt_intro with (X:=X)...
        apply subst_tt_toplike...
    +
      rewrite Lub_recL in H5.
      dependent destruction H5...      
    +
      rewrite Lub_recL in H5.
      dependent destruction H5...   
    +
      simpl in H7.
      dependent destruction H7...
      clear H6.
      apply toplike_rec with (L:=L \u L0 \u L1 \u fv_tt A0 \u fv_tt A1 \u fv_tt A2 \u dom E \u fl_tt A0 \u fl_tt A1).
      intros.
      specialize_x_and_L X L.
      specialize_x_and_L X L0.
      specialize_x_and_L X L1.
      apply H2 in H5...
      *
        apply toplike_twice_to_one in H5...
      *
        rewrite Lub_open in H7...
        rewrite subst_tt_intro with (X:=X)...
        remember (subst_tt X (typ_rcd X (open_tt A1 X)) (open_tt A1 X)).
        rewrite subst_tt_intro with (X:=X)...
        subst.
        apply Lub_toplike_subst...
        get_well_form...
        apply notin_union.
        split;apply notin_fl_tt_open...
  - (* rcd *)
    dependent induction H0...
    +
      simpl in H2...
      dependent destruction H2.
      constructor...
      apply IHSub with (B0:=typ_bot)...
      constructor...
      get_well_form...
    +
      rewrite Lub_rcdL in H2.
      dependent destruction H2...
    +
      rewrite Lub_rcdL in H2.
      dependent destruction H2...
    +
      simpl in H1...
      destruct (l==l)...
      dependent destruction H1...
      constructor...
      apply IHSub with (B0:=A0)...
      destruct n...
Qed.



Inductive posco:  typ -> Prop :=
| PC_nat: 
    posco typ_nat
| PC_top: 
    posco typ_top
| PC_bot: 
    posco typ_bot           
| PC_fvar: forall X,
    posco (typ_fvar X) 
| PC_arrow: forall A1 A2,
    fv_tt A1 [<=] {} ->
    posco A2 ->
    posco  (typ_arrow A1 A2) 
| PC_and: forall  B C,
    posco B ->
    posco C ->
    posco (typ_and B C)      
| PC_rcd: forall Y A,
    posco A ->
    posco (typ_rcd Y A)   
| PC_rec: forall A L,
    (forall Y, Y \notin L -> posco (open_tt A Y))->               
    posco (typ_mu A) 
.

Hint Constructors posco: core.


Lemma mu_transform_4: forall (X Y:atom) A B,
    type B -> X <> Y ->
  subst_tt X B (open_tt A (typ_rcd Y (open_tt A Y))) =
  open_tt (subst_tt X B A) (typ_rcd Y (open_tt (subst_tt X B A) Y)).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal...
  simpl...
  f_equal...
  rewrite subst_tt_open_tt_var...
Qed.
 
  
Lemma posco_subst_aux: forall E A B,
    Sub E A B  ->
    forall  X C ,
      WFS E C ->
      (X \notin fv_tt A -> Sub E A (subst_tt X C B)) /\
      (X \notin fv_tt B -> Sub E (subst_tt X C A) B).
Proof with auto.
  intros E A B H.
  induction H;intros...
  - (* var *)
    split;intros.
    simpl in *.
    destruct (X==X0)...
    apply notin_singleton_1 in H2.
    destruct H2...
    simpl in *.
    destruct (X==X0)...
    apply notin_singleton_1 in H2.
    destruct H2...
  - (* bot *)
    split;intros;simpl...
    constructor...
    apply subst_tt_wfs...
  - (* arrow *)
    split;intros.
    +
      simpl in *.
      constructor...
      destruct IHSub1 with (X:=X) (C:=C)...
      destruct IHSub2 with (X:=X) (C:=C)...
    +
      simpl in *.
      constructor...
      destruct IHSub1 with (X:=X) (C:=C)...
      destruct IHSub2 with (X:=X) (C:=C)...
  - (* and *)
    split;intros.
    +
      simpl in *.
      constructor...
      destruct IHSub1 with (X:=X) (C:=C)...
      destruct IHSub2 with (X:=X) (C:=C)...
    +
      simpl in *.
      constructor...
      destruct IHSub1 with (X:=X) (C:=C)...
      destruct IHSub2 with (X:=X) (C:=C)...
  - (* andL *)
    split;intros.
    +
      simpl in *.
      apply S_andL...
      destruct IHSub with (X:=X) (C:=C)...
    +
      simpl in *.
      apply S_andL...
      destruct IHSub with (X:=X) (C:=C)...
      apply subst_tt_wfs...
  - (* andR *)
    split;intros.
    +
      simpl in *.
      apply S_andR...
      destruct IHSub with (X:=X) (C:=C)...
    +
      simpl in *.
      apply S_andR...
      destruct IHSub with (X:=X) (C:=C)...
      apply subst_tt_wfs...
  - (* rec *)
    split;intros.
    +
      simpl in H4.
      simpl.
      apply S_rec with (L:=L \u fv_tt A1 \u fv_tt A2 \u {{X}} );intros...
      rewrite subst_tt_open_tt_var...
      apply subst_tt_wfs...
      add_nil.
      apply WFS_weakening...
      get_type...
      destruct H2 with (X:=X0) (X0:=X) (C:=C)...
      add_nil.
      apply WFS_weakening...
      rewrite <- mu_transform_4...
      apply H6...
      apply notin_fv_tt_open...
      simpl...
      apply notin_fv_tt_open...
      get_type...
    +
      simpl in H4.
      simpl.
      apply S_rec with (L:=L \u fv_tt A1 \u fv_tt A2 \u {{X}} );intros...
      rewrite subst_tt_open_tt_var...
      apply subst_tt_wfs...
      add_nil.
      apply WFS_weakening...
      get_type...
      destruct H2 with (X:=X0) (X0:=X) (C:=C)...
      add_nil.
      apply WFS_weakening...
      rewrite <- mu_transform_4...
      apply H7...
      apply notin_fv_tt_open...
      simpl...
      apply notin_fv_tt_open...
      get_type...
  - (* rcd *)
    split;intros;simpl;constructor;apply IHSub...
  - (* top *)
    split;intros;simpl...
    +
      apply S_top...
      apply subst_tt_toplike...
    +
      apply S_top...
      apply subst_tt_wfs...
Qed.

Lemma Lub_posco: forall A ,
    type A -> forall B, type B ->
    posco (Lub A B).
Proof with auto.
  intros A HA.
  induction HA;intros B HB;induction HB;try solve [simpl;auto]...
  -
    rewrite Lub_botArr...
    constructor...
    simpl...
    apply Subset_refl...
  -
    rewrite Lub_botRec...
    apply PC_rec with (L:=L \u fv_tt T).
    intros.
    rewrite Lub_open...
  -
    simpl...
    destruct (X==X0)...
  -
    simpl...
    constructor...
    simpl...
    apply Subset_refl...
  -
    simpl...
    constructor...
    simpl...
    apply Subset_refl...
  -
    simpl...
    constructor...
    apply IHHA1...
    apply type_mu with (L:=L)...
    apply IHHA2...
    apply type_mu with (L:=L)...
  -
    simpl...
    destruct (l==l0)...
  -
    simpl...
    apply PC_rec with (L:=L \u  fv_tt T).
    intros.
    rewrite Lub_open...
  -
    simpl...
    apply PC_rec with (L:=L \u L0 \u fv_tt T \u fv_tt T0).
    intros.
    rewrite Lub_open...
Qed.    

Lemma notin_fv_less: forall A X,
    fv_tt A [<=] {} ->
    X \notin fv_tt A.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  assert (X \notin fv_tt A \/ X \in fv_tt A).
  apply in_dec...
  destruct H0...
  apply H in H0.
  apply D.F.empty_iff in H0...
Qed.  


Lemma subst_tt_posco: forall A B X,
    type A ->
    posco A ->
    posco B ->
    posco (subst_tt X A B).
Proof with auto.
  intros.
  generalize dependent A.
  dependent induction H1;intros;try solve [simpl;auto]...
  -
    simpl...
    destruct (X0==X)...
  -
    simpl...
    constructor...
    rewrite <- subst_tt_fresh...
    apply notin_fv_less...
  -
    simpl...
    apply PC_rec with (L:=L \u {{X}} )...
    intros.
    rewrite subst_tt_open_tt_var...
Qed.    
    


  
Lemma posco_subst: forall E A B,
    Sub E A B  ->
    forall  X C D,
      posco B ->
      Sub E C D ->
    Sub E (subst_tt X C A) (subst_tt X D B).
Proof with auto.
  intros E A B H.
  induction H;intros...
  -
    simpl...
    destruct (X==X0)...
  -
    simpl...
    constructor...
    apply subst_tt_wfs...
    get_well_form...
  -
    simpl.
    dependent destruction H1.
    constructor...
    apply posco_subst_aux with (X:=X) (C:=C) in H...
    destruct H.
    apply notin_fv_less with (X:=X) in H1.
    rewrite <- subst_tt_fresh...
    get_well_form...
  -
    dependent destruction H1.
    simpl...
  -
    simpl...
    apply S_andL...
    apply subst_tt_wfs...
    get_well_form...
  -
    simpl...
    apply S_andR...
    apply subst_tt_wfs...
    get_well_form...
  -
    dependent destruction H3...
    simpl...
    apply S_rec with (L:=L \u L0 \u fv_tt A1 \u fv_tt A2 \u {{X}} \u dom E);intros...
    rewrite subst_tt_open_tt_var...
    apply subst_tt_wfs...
    add_nil.
    apply WFS_weakening...
    get_well_form...
    get_type...
    rewrite subst_tt_open_tt_var...
    apply subst_tt_wfs...
    add_nil.
    apply WFS_weakening...
    get_well_form...
    get_type...
    rewrite <- mu_transform_4...
    rewrite <- mu_transform_4...
    apply H2...
    rewrite subst_tt_intro with (X:=X0)...
    apply subst_tt_posco...
    constructor...
    specialize_x_and_L X0 L.
    get_type...
    add_nil.
    apply Sub_weakening...
    constructor...
    get_well_form...
    get_type...
    get_type...
  -
    simpl...
    constructor...
    dependent destruction H0...
  -
    simpl...
    apply S_top...
    apply subst_tt_wfs...
    get_well_form...
    apply subst_tt_toplike...
    get_well_form...
Qed.

Lemma Sub_Lub_subst: forall A B C D X E,
    type B ->
    Sub E A (Lub A B) ->
    Sub E C D ->
    Sub E (subst_tt X C A) (subst_tt X D (Lub A B)).
Proof with auto.
  intros.
  apply posco_subst...
  apply Lub_posco...
  get_type...
Qed.
  

Lemma Lub_subL: forall E A B ,
    WFS E B -> WFS E A -> wf_env E ->
    Sub E A (Lub A B).
Proof with auto.
  intros.
  generalize dependent B.
  induction H0;intros;try solve [induction H;simpl;auto]...
  -
    constructor...
    apply WFS_Lub...
  -
    induction H0;simpl...
    destruct (X==X0)...
  -
    rewrite Lub_andR.
    constructor...
  -
    induction H;simpl...
    destruct (l==l0)...
  -
    assert (WFS E (typ_mu A)).
    apply WFS_rec with (L:=L)...
    induction H4;simpl...
    +
      apply S_rec with (L:=L  \u fv_tt A \u dom E);intros...
      rewrite Lub_open...
      apply WFS_Lub...
      rewrite subst_tt_intro with (X:=X)...
      remember (subst_tt X (typ_rcd X (open_tt A X)) (open_tt A X)).
      rewrite subst_tt_intro with (X:=X)...
      subst.
      rewrite Lub_open...
      apply Sub_Lub_subst...
      apply Lub_fv_notin...      
    +
      clear H6 H8.
      apply S_rec with (L:=L \u L0 \u fv_tt A \u fv_tt A0 \u dom E);intros...
      rewrite Lub_open...
      apply WFS_Lub...
      rewrite Lub_open...
      rewrite subst_tt_intro with (X:=X)...
      remember (subst_tt X (typ_rcd X (open_tt A X)) (open_tt A X)).
      rewrite subst_tt_intro with (X:=X)...
      subst.
      rewrite Lub_open...
      apply Sub_Lub_subst...
      specialize_x_and_L X L0.
      get_type...
      apply Lub_fv_notin...      
Qed.



Lemma Sub_Lub_subst_rev: forall A B C D X E,
    type A ->
    Sub E B (Lub A B) ->
    Sub E C D ->
    Sub E (subst_tt X C B) (subst_tt X D (Lub A B)).
Proof with auto.
  intros.
  apply posco_subst...
  apply Lub_posco...
  get_type...
Qed.
  

Lemma Lub_subR: forall E A B ,
    WFS E B -> WFS E A -> wf_env E ->
    Sub E B (Lub A B).
Proof with auto.
  intros.
  generalize dependent A.
  induction H;intros;try solve [induction H0;simpl;auto]...
  -
    constructor...
    apply WFS_Lub...
  -
    induction H0;simpl...
    destruct (X0==X)...
    subst.
    constructor...
  -
    induction H2;try solve [simpl;auto]...
    rewrite Lub_botArr.
    constructor...
  -
    apply Transitivity with (B:=typ_and (Lub A0 A) (Lub A0 B))...
    apply Lub_andL...
  -
    induction H0;try solve [simpl;auto]...
    rewrite Lub_botRcd...
    simpl.
    destruct (l0==l)...
    subst.
    constructor...
  -
    assert (WFS E (typ_mu A)).
    apply WFS_rec with (L:=L)...
    induction H4;try solve [simpl;auto]...
    +
      rewrite Lub_botRec...
      apply S_rec with (L:=L  \u fv_tt A \u dom E);intros...
      rewrite Lub_open...
      apply WFS_Lub...
      rewrite subst_tt_intro with (X:=X)...
      remember (subst_tt X (typ_rcd X (open_tt A X)) (open_tt A X)).
      rewrite subst_tt_intro with (X:=X)...
      subst.
      rewrite Lub_open...
      apply Sub_Lub_subst_rev...
      apply Lub_fv_notin...      
    +
      clear H6 H8.
      simpl.
      apply S_rec with (L:=L \u L0 \u fv_tt A \u fv_tt A0 \u dom E);intros...
      rewrite Lub_open...
      apply WFS_Lub...
      rewrite Lub_open...
      rewrite subst_tt_intro with (X:=X)...
      remember (subst_tt X (typ_rcd X (open_tt A X)) (open_tt A X)).
      rewrite subst_tt_intro with (X:=X)...
      subst.
      rewrite Lub_open...
      apply Sub_Lub_subst_rev...
      specialize_x_and_L X L0.
      get_type...
      apply Lub_fv_notin...      
Qed.

Lemma Lub_sub: forall E A B ,
    WFS E B -> WFS E A -> wf_env E ->
    Sub E A (Lub A B) /\ Sub E B (Lub A B).
Proof with auto.
  intros.
  split.
  apply Lub_subL...
  apply Lub_subR...
Qed.  

Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export infra.


Inductive sub : env -> typ -> typ -> Prop :=
| Sa_nat: forall E,
    sub E typ_nat typ_nat
| Sa_fvar: forall E X,
    sub E (typ_fvar X) (typ_fvar X)
| Sa_top : forall E A,
    sub E A typ_top
| Sa_bot : forall E A,
    sub E typ_bot A        
| Sa_arrow: forall E A1 A2 B1 B2,
    sub E B1 A1 ->
    sub E A2 B2 ->
    sub E (typ_arrow A1 A2) (typ_arrow B1 B2)
| Sa_and : forall E A B1 B2,
    sub E A B1 ->
    sub E A B2 ->
    sub E A (typ_and B1 B2)
| Sa_andL : forall E A1 A2 B,
    sub E A1 B ->
    sub E (typ_and A1 A2) B
| Sa_andR : forall E A1 A2 B,
    sub E A2 B ->
    sub E (typ_and A1 A2) B
| Sa_rec: forall L A1 A2 E,
    (forall X,
        X \notin L ->
        sub (X ~ bind_sub ++ E) (open_tt A1 X) (open_tt A2 X)) ->
    (forall X,
        X \notin L ->
        sub (X ~ bind_sub ++ E) (open_tt A1 (open_tt A1 X)) (open_tt A2 (open_tt A2 X))) ->
    sub E (typ_mu A1) (typ_mu A2)
| Sa_rcd : forall A B l E,
    sub E A B ->
    sub E (typ_rcd l A) (typ_rcd l B)
.

(*
Fixpoint unfoldT (A : typ) X (n : nat) :=
  match n with
  | 0 => open_tt A (typ_fvar X)
  | (S i) => open_tt A (unfoldT A X i)
  end.

Inductive Sub : env -> typ -> typ -> Prop :=
| SA_nat: forall E,
    Sub E typ_nat typ_nat
| SA_fvar: forall E X,
    Sub E (typ_fvar X) (typ_fvar X)
| SA_top : forall E A,
    Sub E A typ_top
| SA_bot : forall E A,
    Sub E typ_bot A        
| SA_arrow: forall E A1 A2 B1 B2,
    Sub E B1 A1 ->
    Sub E A2 B2 ->
    Sub E (typ_arrow A1 A2) (typ_arrow B1 B2)
| SA_and : forall E A B1 B2,
    Sub E A B1 ->
    Sub E A B2 ->
    Sub E A (typ_and B1 B2)
| SA_andL : forall E A1 A2 B,
    Sub E A1 B ->
    Sub E (typ_and A1 A2) B
| SA_andR : forall E A1 A2 B,
    Sub E A2 B ->
    Sub E (typ_and A1 A2) B
| SA_rec: forall L A1 A2 E,
    (forall n X,
        X \notin L ->
        Sub ((X ~ bind_sub) ++ E)  (unfoldT A1 X n) (unfoldT A2 X n)) ->
    Sub E (typ_mu A1) (typ_mu A2)
| SA_rcd : forall A B l E,
    Sub E A B ->
    Sub E (typ_rcd l A) (typ_rcd l B)
.
*)



Hint Constructors  sub : core.
     
Definition A1 := typ_and (typ_and typ_nat (typ_bvar 0)) (typ_arrow (typ_bvar 0) typ_nat).
Definition B1 := typ_and (typ_bvar 0) (typ_arrow (typ_bvar 0) typ_nat).

Definition A := typ_mu A1.
Definition B := typ_mu B1.

  

Lemma test_triple_unfolding: forall X,
    sub (X~bind_sub) (open_tt A1 (open_tt A1 (open_tt A1 X))) (open_tt B1 (open_tt B1 (open_tt B1 X))).
Proof with auto.
  intros.
  unfold open_tt;simpl...
  apply Sa_and...
  -
    apply Sa_and...
    +
      apply Sa_and...
      *
        apply Sa_andL...
        apply Sa_andR...
      *
        apply Sa_andL...
        apply Sa_andR...
    +
      apply Sa_andL...
      apply Sa_andR...
      apply Sa_andL...
  -
    apply Sa_andL...
    apply Sa_andR...
    apply Sa_andL...
    apply Sa_andR...
Qed.

  
Lemma test_double_unfolding:
    sub empty A B.
Proof with auto.
  unfold A.
  unfold B.
  apply Sa_rec with (L:={});intros...
  -
    unfold open_tt.
    simpl...
  -
    unfold open_tt.
    simpl...
    apply Sa_and...
    +
      apply Sa_and...
    +
      apply Sa_andL...
Qed.


Lemma test_unfolding_lemma:
  sub empty A B ->
  sub empty (open_tt A1 A) (open_tt B1 B) ->
  False.
Proof with auto.
  unfold A.
  unfold B.
  unfold A1.
  unfold B1.
  unfold open_tt.
  simpl.
  intros.
  dependent destruction H...
  dependent destruction H1...
  -
    dependent destruction H1_...
    +
      dependent destruction H1_...
      dependent destruction H1_...
      dependent destruction H1_0...
      *
        dependent destruction H1_0...
        dependent destruction H1_0...
        dependent destruction H1_0...
      *
        dependent destruction H1_0...
        dependent destruction H1_0_1...
        dependent destruction H1_...
        pick fresh X.
        specialize_x_and_L X L.
        specialize_x_and_L X L1.
        specialize_x_and_L X L0.
        unfold open_tt in *;simpl in *...
        dependent destruction H3...
        --
          dependent destruction H3_...
          ++
            dependent destruction H3_1...
            dependent destruction H3_1...
            dependent destruction H3_1...
          ++
            dependent destruction H3_...
            dependent destruction H3_1...
          ++
            dependent destruction H3_...
            dependent destruction H3_1...
        --
          dependent destruction H3...
          dependent destruction H3_...
          dependent destruction H3_1...
        --
          dependent destruction H3...
          dependent destruction H3_...
          dependent destruction H3_1...
    +
      dependent destruction H1_...
  -
    dependent destruction H1...
    +
      dependent destruction H1_...
      dependent destruction H1_...
      dependent destruction H1_0...
      dependent destruction H1_0...
      dependent destruction H1_0...
    +
      dependent destruction H1...
      dependent destruction H1_...
    +
      dependent destruction H1...
      dependent destruction H1_0...
  -
    dependent destruction H1...
    dependent destruction H1_...
Qed.
          
(*
mu x. ( nat & ( ( nat -> nat ) & ( x -> nat ) ) ) 
mu x. ( nat & ( x -> nat ) ) 
*)

Definition C1 := typ_and typ_nat (typ_and (typ_arrow typ_nat typ_nat) (typ_arrow (typ_bvar 0) typ_nat)).
Definition D1 := typ_and typ_nat (typ_arrow (typ_bvar 0) typ_nat).

Definition C := typ_mu C1.
Definition D := typ_mu D1.

Lemma test_sub_C_D:
  sub empty C D.
Proof with auto.
  unfold C.
  unfold D.
  apply Sa_rec with (L:={});intros...
  -
    unfold C1.
    unfold D1.
    unfold open_tt;simpl...      
  -
    unfold C1.
    unfold D1.
    unfold open_tt;simpl...
    apply Sa_and...
Qed.

Lemma test_notsub_D_C:
  sub empty D C ->
  False.
Proof with auto.
  intros.
  unfold D in *.
  unfold C in *.
  dependent destruction H.
  pick fresh X.
  specialize (H _ Fr).
  clear H0.
  unfold open_tt in *.
  simpl in *...
  dependent destruction H...
  -
    dependent destruction H0...
    dependent destruction H0_...
    dependent destruction H0_...
    dependent destruction H0_...
    dependent destruction H0_1...
    dependent destruction H0...
    dependent destruction H0_...
    dependent destruction H0...
    dependent destruction H0_...
    dependent destruction H0_1...
  -
    dependent destruction H...
    dependent destruction H0...
    dependent destruction H0_...
  -
    dependent destruction H...
    dependent destruction H...
Qed.
    
Lemma test_unfolding_lemma_C_D:
  sub empty (open_tt C1 C) (open_tt D1 D) ->
  False.
Proof with auto.
  unfold open_tt.
  simpl...
  intros.
  dependent destruction H...
  -
    dependent destruction H0...
    +
      dependent destruction H0...
    +
      dependent destruction H0...
      *
        dependent destruction H0...
        dependent destruction H0_...
      *
        dependent destruction H0...
        apply test_notsub_D_C in H0_...
  -
    dependent destruction H...
    dependent destruction H0...
  -
    dependent destruction H...
    +
      dependent destruction H0...
      dependent destruction H0...
      dependent destruction H0_...
      dependent destruction H0...
      apply test_notsub_D_C in H0_...
    +
      dependent destruction H...
      dependent destruction H...
    +
      dependent destruction H...
      dependent destruction H...
Qed.
